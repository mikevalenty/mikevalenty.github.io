<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Decorator Pattern | Agile at Work]]></title>
  <link href="http://mikevalenty.github.io/blog/categories/decorator-pattern/atom.xml" rel="self"/>
  <link href="http://mikevalenty.github.io/"/>
  <updated>2013-09-30T21:42:03-07:00</updated>
  <id>http://mikevalenty.github.io/</id>
  <author>
    <name><![CDATA[Michael Valenty]]></name>
    <email><![CDATA[mike@valenty.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Configuring Decorators with Google Guice]]></title>
    <link href="http://mikevalenty.github.io/configuring-decorators-with-google-guice/"/>
    <updated>2012-02-20T07:11:00-08:00</updated>
    <id>http://mikevalenty.github.io/configuring-decorators-with-google-guice</id>
    <content type="html"><![CDATA[<p>You have a few options and each have their trade-offs. The one I find least annoying requires using a binding annotation. Since I’m stuck using annotations with Guice anyway, using one more to facilitate a decorator seems like an acceptable concession. Before I go on though, I have to take a moment. My beef isn’t about verbose configuration or annotations, it’s that once again the documentation gets it all wrong and sends the impressionable reader down a misguided path. Let’s take a look at this excerpt from the Guice documentation for binding annotations:</p>

<p>``` java
public class RealBillingService implements BillingService {</p>

<p>  @Inject
  public RealBillingService(@PayPal CreditCardProcessor processor, &hellip;) {</p>

<pre><code>...
</code></pre>

<p>  }
```</p>

<p>This bit of innocuous code encourages the reader to squander the power of dependency inversion and reduce it to a clunky tool that makes unit testing a little bit easier. That sounds harsh, so let’s start by discussing what Guice is and the problem it solves.</p>

<p>Guice and the like are referred to as IoC containers. That’s Inversion of Control. It’s a pretty general principle and when applied to object oriented programming, it manifests itself in the form of a technique called <em>Dependency Inversion</em>. In terms of the <code>BillingService</code> example, it means the code depends on a <code>CreditCardProcessor</code> abstraction rather than new‘ing something specific like a <code>PayPalCreditCardProcessor</code>. Perhaps depends is an overloaded term here. With or without the new keyword, there is a dependency. In one case, a higher level module is responsible for deciding what implementation to use, and in the other case, the class itself decides that it’s using a <code>PayPalCreditCardProcessor</code>, period.</p>

<p>Writing all your classes to declare their dependencies leaves you with the tedious task of building up complex object graphs before you can actually use your object. This is where Guice comes in. It’s a tool to simplify the havoc wreaked by inverting your dependencies and it’s inevitable when guided by a few principles like DRY (Don’t Repeat Yourself). If you don’t believe me, go ahead a see for yourself. Write some truly SOLID code and you’ll end up writing an IoC container in the process.</p>

<p>So now that we’ve covered what Guice is and the problem it solves, we are ready to talk about what’s wrong with <code>@PayPal</code>. Specifying the concrete class you expect with an annotation is pretty much the same as just declaring the dependency explicitly. Sure, you get a few points for using an interface and injecting the object, but it’s really just going through the motions while entirely missing the point. It would be like the Karate Kid going into auto detailing after learning wax-on, wax-off.</p>

<p>Abstractions create seams in your code. It’s how you add new behavior as the application evolves and it’s the key to managing complexity. Since we’re looking at a billing example, let’s throw out a few requirements that could pop up. How about some protection against running the same transaction twice in a short time period. How about checking a blacklist of credit cards or customers. Or maybe you need a card number that always fails in a particular way so QA can test the sad path. Or maybe your company works with a few payment gateways and wants to choose the least cost option based on the charge amount or card type. In this little snippet of code, we’ve got 2 seams we can use to work in this behavior. We’ve got the <code>BillingService</code> and <code>CreditCardProcesor</code>.</p>

<p>Oh, wait a minute we’re declaring that we need the <code>PayPalCreditCardProcessor</code> with that annotation so now our code is rigid and we can’t inject additional behavior by wrapping it in a <code>DoubleChargeCreditCardProcessor</code>, open-closed style. That’s the ‘O’ in SOLID. So you’re probably thinking, why can’t you just change the annotation from <code>@PayPal</code> to <code>@DoubleCharge</code>? Let’s dive a little deeper into this example to find out:</p>

<p>``` java
public class DoubleChargeCreditCardProcessor implements CreditCardProcessor {</p>

<p>  @Inject
  public DoubleChargeCreditCardProcessor(CreditCardProcessor processor, &hellip;) {</p>

<pre><code>...
</code></pre>

<p>  }
```</p>

<p>I’m not going to rant about how extends is evil and that you’re better off with a decorator because I’ve already done that, and this article is about how to wire up a decorator with Guice. So the challenge here is how to configure the container to supply the correct credit card processor as the first dependency of our double charge processor which itself implements <code>CreditCardProcessor</code>. Looking at the Guice documentation, you would likely think the answer is to do this:</p>

<p>``` java
public class RealBillingService implements BillingService {</p>

<p>  @Inject
  public RealBillingService(@DoubleCharge CreditCardProcessor processor, &hellip;) {</p>

<pre><code>...
</code></pre>

<p>  }
```</p>

<p>``` java
public class DoubleChargeCreditCardProcessor implements CreditCardProcessor {</p>

<p>  @Inject
  public DoubleChargeCreditCardProcessor(@PayPal CreditCardProcessor processor, &hellip;) {</p>

<pre><code>...
</code></pre>

<p>  }
```</p>

<p>That’s wrong though. The <code>CreditCardProcessor</code> isn’t a thing, it’s a seam and it’s where you put additional behavior like preventing duplicate charges in a short time period. If you look at the decorator, you’ll notice that it has nothing to do with PayPal. That’s because it’s a business rule and shouldn’t be mixed with integration code. Our business rule code and the PayPal integration code will likely live in different packages and the <code>CreditCardProcessor</code> abstraction could get assembled differently for any number of reasons. Maybe your application supports multi-tenancy and each tenant can use a different payment gateway. We can’t reuse our double charge business rule if it’s hard-coded to wrap a PayPal processor, and that’s a problem.</p>

<p>While I don’t particularly like using annotations for this sort of thing, it’s not the root cause. As a mechanic, it works just fine and can help us accomplish our task. The problem is that the documentation is subtly wrong and encourages mis-use of this feature. Chances are the original author of Guice and the person writing the documentation for binding annotations aren’t the same person so it’s understandable that a detail like this could get lost in the shuffle. The correct way to use binding annotations and not undermine the point of injecting your dependencies in the first place is like so:</p>

<p>``` java
public class DoubleChargeCreditCardProcessor implements CreditCardProcessor {</p>

<p>  public static final String BASE = &ldquo;DoubleChargeCreditCardProcessor.base&rdquo;;</p>

<p>  public DoubleChargeCreditCardProcessor(@Named(BASE) CreditCardProcessor processor, &hellip;) {</p>

<pre><code>...
</code></pre>

<p>  }
```</p>

<p>``` java
public class ConfigureCreditCardProcessor extends AbstractModule {</p>

<p>  @Override
  protected void configure() {</p>

<pre><code>bind(CreditCardProcessor.class).to(DoubleChargeCreditCardProcessor.class);

bind(CreditCardProcessor.class)
  .annotatedWith(Names.named(DoubleChargeCreditCardProcessor.BASE))
  .to(PayPayCreditCardProcessor.class);
</code></pre>

<p>  }
}
```</p>

<p>Did you catch the difference? It’s subtle, but the devil is in the details. In this last example, the DoubleChargeCreditCardProcessor doesn’t know or care what implementation it’s decorating. It simply declares a name for it’s dependency so it can be referenced unambiguously in a configuration module. This moves the configuration logic to… well, configuration code. Now you can see that the code is once again flexible and you can easily imagine more sophisticated configuration logic that could consider tenant settings or environment variables in selecting the proper combination of credit card processors to assemble.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder]]></title>
    <link href="http://mikevalenty.github.io/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/"/>
    <updated>2010-01-04T06:52:00-08:00</updated>
    <id>http://mikevalenty.github.io/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder</id>
    <content type="html"><![CDATA[<p>The <code>DataAnnotationsModelBinder</code> is a pretty neat little class that enforces validation attributes on models like this one:</p>

<p>``` c#
public class Product {</p>

<pre><code>public int Id { get; set; }

[Required]
public string Description { get; set; }

[Required]
[RegularExpression(@"^\$?\d+(\.(\d{2}))?$")]
public decimal UnitPrice { get; set; }
</code></pre>

<p>}
```</p>

<p>Just for the record, this is a <a href="http://aspnet.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=24471">cool bit of code</a> that was released to the community for backseat drivers like me to use and complain about. I’m really only bitter because I can’t use it. Let’s take a peek at the source code to see why:</p>

<p>``` c#
/// <summary>
/// An implementation of IModelBinder which is designed to be a replacement
/// default model binder, adding the functionality of validation via the validation
/// attributes in System.ComponentModel.DataAnnotations from .NET 4.0.
/// </summary>
public class DataAnnotationsModelBinder : DefaultModelBinder {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>The problem with this class is that it’s not just about validation. It’s more about binding with validation sprinkled in. The author even states this as a design goal with the comment “designed to be a replacement default model binder.” This is a violation of the <em>Single Responsibility Principle</em> and it’s the reason I can’t use it. The <code>DefaultModelBinder</code> does some basic reflection mapping of form elements to model properties. That’s cool, but what about a controller action that takes json, xml, or anything slightly more complicated than what the default binder can handle?</p>

<p>I’ll tell you what happens. You write a custom model binder which is pretty easy and happens to be a pretty rad extension point in the MVC framework. Consider this model binder that deserializes json:</p>

<p>``` c#
public class JsonModelBinder<T> : IModelBinder {</p>

<pre><code>private string key;

public JsonModelBinder(string requestKey) {
    this.key = requestKey;
}

public object BindModel(ControllerContext controllerContext, ...) {
    var json = controllerContext.HttpContext.Request[key];
    return new JsonSerializer().Deserialize&lt;T&gt;(json);
}
</code></pre>

<p>}
```</p>

<p>That’s pretty cool, but now I’ve lost my validation! This my friend is the evil of inheritance and the epic fail of the <code>DataAnnotationsModelBinder</code>. So what’s wrong with inheritance, isn’t that what OOP is all about? The short answer is no (the long answer is also no.)</p>

<p><img class="plain" src="/images/posts/petervenkmanghostbusters.jpg"></p>

<blockquote><p>Human sacrifice, dogs and cats living together… mass hysteria! — Dr. Peter Venkman</p></blockquote>

<p>Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to another other class, right? Well, one of the problems is that inheritance is probably the worst form of coupling you can have. Your base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile.</p>

<p>The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain. Why does a model that enforces validation attributes care how the model is constructed? The answer is it shouldn’t, and to add insult to injury, the better design is actually easier to implement. Listen closely and you may hear the wise whispers of our forefathers…</p>

<p><img class="plain" src="/images/posts/ward.jpg" title="Ward Cunningham" >
<img class="plain" src="/images/posts/martin.jpg" title="Marting Fowler" >
<img class="plain" src="/images/posts/kent.jpg" title="Kent Beck" >
<img class="plain" src="/images/posts/robert.jpg" title="Robert Martin" ></p>

<blockquote><p>Use the decorator pattern.</p></blockquote>

<p>Is this really going to solve all my problems? The short answer is yes. Let’s take a look:</p>

<p>``` c#
public class BetterDataAnnotationsModelBinder : IModelBinder {</p>

<pre><code>private IModelBinder binder;

public BetterDataAnnotationsModelBinder(IModelBinder binder) {
    this.binder = binder;
}

public object BindModel(ControllerContext controllerContext, ...) {
    var model = binder.BindModel(controllerContext, bindingContext);
    AddValidationErrorsToModelState(model, controllerContext);
    return model;
}

...
</code></pre>

<p>}
```</p>

<p>Now all this class does is enforce validation and we can use whatever model binder we want to construct our object. Let’s wire this up in the <code>Global.asax</code> real quick:</p>

<p>``` c#
var productModelBinder = new JsonModelBinder<Product>(&ldquo;product&rdquo;);</p>

<p>ModelBinders.Binders.Add(</p>

<pre><code>typeof(Product),
new BetterDataAnnotationsModelBinder(productModelBinder));
</code></pre>

<p>```</p>

<p>This is cool for the following reasons:</p>

<ol>
<li>We are not coupled to the <code>DefaultModelBinder</code>. This means we don’t know or care about the structure and implementation details of it so it’s free to change in the next version of ASP.NET MVC.</li>
<li>The code is simpler because it is only about validation.</li>
<li>The behavior is composable. This means we can add validation to any model binder (like our json model binder) and bolt on more responsibilities with a chain of decorators. How about converting DateTime fields to UTC or striping formatting characters from phone numbers?</li>
<li>It’s easy to test.</li>
<li>You can substitute a decorator for a subclass in most cases and in most cases it’s the right choice. You’re better off making the decorator your default choice and only settle for inheritance when you really need it.</li>
</ol>


<p><img class="plain" src="/images/posts/kip.jpg"></p>

<blockquote><p>…don’t be jealous that I’ve been chatting online with babes all day. Besides, we both know that I’m training to be a cage fighter. — Kip</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom Model Binder in ASP.NET MVC]]></title>
    <link href="http://mikevalenty.github.io/custom-model-binder-in-asp-dot-net-mvc/"/>
    <updated>2009-12-31T14:59:00-08:00</updated>
    <id>http://mikevalenty.github.io/custom-model-binder-in-asp-dot-net-mvc</id>
    <content type="html"><![CDATA[<p>The default model binder or <code>DataAnnotationsModelBinder</code> in ASP.NET MVC works well for simple data structures that basically map properties directly to form elements, but it quickly breaks down in a real world application. Take this simple scenario:</p>

<p><img class="plain" src="/images/posts/brimley.png"></p>

<p>The built-in model binder can handle the easy fields like <code>FirstName</code>, <code>LastName</code>, and <code>Email</code>, but it doesn’t know how to deal with the <code>Roles</code>. This is where the custom model binder comes in:</p>

<p>``` c#
public class UserModelBinder : IModelBinder {</p>

<pre><code>private readonly IModelBinder binder;

public UserModelBinder(IModelBinder binder) {
    this.binder = binder;
}

public object BindModel(ControllerContext controllerContext, ...) {
    var user = (User)binder.BindModel(controllerContext, bindingContext);
    AddRoles(user, controllerContext);
    return user;
}

private static void AddRoles(User user, ControllerContext controllerContext) {
    foreach (var role in GetRoles(controllerContext)) {
        user.Add(role);
    }
}

private static IEnumerable&lt;Role&gt; GetRoles(ControllerContext controllerContext) {
    var roles = controllerContext.HttpContext.Request["roles"];
    if (roles == null) yield break;
    foreach (var roleId in roles.Split(',')) {
        yield return (Role)Convert.ToInt32(roleId);
    }
}
</code></pre>

<p>}
```</p>

<p>And it gets wired-up in the <code>Global.asax</code> like this:</p>

<p><code>c#
var defaultBinder = new DataAnnotationsModelBinder();
ModelBinders.Binders.DefaultBinder = defaultBinder;
ModelBinders.Binders.Add(typeof(User), new UserModelBinder(defaultBinder));
</code></p>

<p>Because <code>UserModelBinder</code> is a decorator, it preserves the base functionality (like validation) of the default binder and only adds the part about mapping the roles. This is good stuff because it keeps construction of the model out of the controller. That’s the Single-Responsibility Principle in action.</p>

<h2>Command Query Separation</h2>

<p>The two functions <code>AddRoles</code>, and <code>GetRoles</code> are an example of command query separation (CQS). It would be easy to combine those two functions together and in fact that’s how it looked at first. So why bother separating them? Well it doesn’t really matter in this simple case, but it’s like how I tell my 3 year-old son to move his milk cup away from the edge of the table. I figure it’s a good habit that will prevent a few spills in the long run. The idea with CQS is there is a natural seam between finding objects and doing stuff with them. I buy that. I expect <code>GetRoles</code> to be more volatile than <code>AddRoles</code> or at least change for different reasons.</p>
]]></content>
  </entry>
  
</feed>
